"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Namespace = _interopRequireDefault(require("./Namespace"));

var _JSObjectNamespace = _interopRequireWildcard(require("./JSObjectNamespace"));

var _exceptions = require("../../exceptions");

var _ContainerNamespace = _interopRequireDefault(require("./ContainerNamespace"));

var _InspectorObjectNamespace = _interopRequireDefault(require("./InspectorObjectNamespace"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const path = require("path");

class InspectorFrameNamespace extends _Namespace.default {
  constructor(inspector, frame) {
    super();
    this.inspector = inspector;
    this.frame = frame;
    this.rawPosition = null;
    this.position = null;
  }

  readAttribute(name) {
    if ('this' === name) {
      if (undefined !== this.frame.this) {
        return _InspectorObjectNamespace.default.getObject(this.inspector, this.frame.this);
      } else {
        throw new _exceptions.RookAttributeNotFound(name);
      }
    } else {
      for (let scope of this.frame.scopeChain) {
        const scopeObject = this.inspector.getProperties(scope.object, false);

        for (let potentialValue of scopeObject) {
          if (potentialValue.name === name) {
            return _InspectorObjectNamespace.default.getObject(this.inspector, potentialValue.value);
          }
        }
      }
    }

    throw new _exceptions.RookAttributeNotFound(name);
  }

  callMethod(name, args) {
    switch (name) {
      case "filename":
      case "module":
        return this.filename();

      case "line":
        return this.line();

      case "function":
      case "method":
        return this.function();

      case "locals":
        return this.locals(args);

      case "dump":
        return this.dump(args);

      default:
        return super.callMethod(name, args);
    }
  }

  filename() {
    return new _JSObjectNamespace.default(this.getPosition().filename);
  }

  module() {
    return this.filename();
  }

  line() {
    return new _JSObjectNamespace.default(this.getPosition().line);
  }

  function() {
    return new _JSObjectNamespace.default(this.getPosition().function);
  }

  locals(args) {
    let result = {};
    let depth = null,
        dumpConfig = null;

    if (null != args && '' !== args) {
      depth = parseInt(args);

      if (isNaN(depth)) {
        depth = null;
        dumpConfig = _JSObjectNamespace.dumpConfigs[args.toLowerCase()];

        if (dumpConfig === undefined) {
          throw new _exceptions.RookInvalidMethodArguments('locals()', args);
        }
      }
    }

    if (this.frame.this !== undefined && this.frame.this.className !== 'global') {
      result['this'] = _InspectorObjectNamespace.default.getObject(this.inspector, this.frame.this);
    } // We iterate from the top down to get all scopes in the correct order, skipping the top scope (Global/Injected)


    for (var scopeIndex = 0; scopeIndex < this.frame.scopeChain.length; scopeIndex++) {
      let scope = this.frame.scopeChain[scopeIndex];
      let nextScope = this.frame.scopeChain[scopeIndex + 1];

      if (scope.type === 'local' || scope.type === 'catch' || scope.type == 'block' || scope.type === 'closure' && (undefined == nextScope || nextScope.type !== 'global')) {
        const scopeObject = this.inspector.getProperties(scope.object, false);

        for (let value of scopeObject) {
          result[value.name] = _InspectorObjectNamespace.default.getObject(this.inspector, value.value);

          if (null != depth) {
            result[value.name].dumpConfig.maxDepth = depth;
          } else {
            if (null != dumpConfig) {
              result[value.name].dumpConfig = dumpConfig;
            }
          }
        }
      }
    }

    return new _ContainerNamespace.default(result);
  }

  dump(args) {
    return new _ContainerNamespace.default({
      locals: this.locals(args),
      module: this.module(),
      filename: this.filename(),
      line: this.line(),
      function: this.function()
    });
  }

  getPosition() {
    if (null !== this.position) {
      return this.position;
    }

    const script = this.inspector.getScript(this.frame.location.scriptId);
    let rawFilename = null;

    if (null !== script) {
      rawFilename = script.filename;
    } else {
      if (this.frame.url !== undefined) {
        rawFilename = path.basename(this.frame.url);
      }
    }

    this.rawPosition = {
      filename: rawFilename,
      line: this.frame.location.lineNumber + 1,
      column: this.frame.location.columnNumber,
      function: this.frame.functionName
    };

    if (null !== script && null !== script.mapConsumer) {
      let originalPosition = script.getOriginalPosition(this.rawPosition.line, this.rawPosition.column);

      if (null != originalPosition) {
        // In case of bad mapping we skip the resolve.
        if (originalPosition.line === null) {
          originalPosition = this.rawPosition;
        }

        this.position = {
          filename: originalPosition.source,
          line: originalPosition.line,
          column: originalPosition.column,
          function: this.rawPosition.function
        };

        if (this.position.function === '' && (typeof originalPosition.name === 'string' || originalPosition.name instanceof String)) {
          this.position.function = originalPosition.name;
        }
      }
    } // If we have been unable to get original position, just use raw position


    if (null == this.position) {
      this.position = this.rawPosition;
    }

    if (this.position.function === '') {
      this.position.function = 'anonymous';
    }

    return this.position;
  }

}

exports.default = InspectorFrameNamespace;
//# sourceMappingURL=InspectorFrameNamespace.js.map